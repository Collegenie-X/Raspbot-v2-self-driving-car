1
00:00:00,450 --> 00:00:01,840
Welcome to discourse.
토론에 오신 것을 환영합니다.

2
00:00:01,860 --> 00:00:06,810
So from our previous video we have created a new lane finder function.
그래서 이전 비디오에서 새로운 차선 찾기 기능을 만들었습니다.

3
00:00:06,810 --> 00:00:16,150
So if I run my program from of a lean finder function we have created these two green lines and now
따라서 린 파인더 기능에서 내 프로그램을 실행하면 이 두 개의 녹색 선이 생성되었으며 이제

4
00:00:16,190 --> 00:00:20,440
in the next step from these two lanes I will find a lean center.
이 두 차선의 다음 단계에서 나는 린 센터를 찾을 것입니다.

5
00:00:21,280 --> 00:00:25,340
So let's find a lane center.
그럼 차선 중심을 찾아봅시다.

6
00:00:25,360 --> 00:00:26,950
This is my lane center.
제 레인 센터입니다.

7
00:00:26,950 --> 00:00:30,880
So the question is how I can find that distance for this lane center.
따라서 문제는 이 차선 중심에 대한 거리를 어떻게 찾을 수 있느냐는 것입니다.

8
00:00:31,330 --> 00:00:32,920
I have the value of it.
나는 그것의 가치가 있습니다.

9
00:00:32,920 --> 00:00:35,530
That means my left lane position.
내 왼쪽 차선 위치를 의미합니다.

10
00:00:35,530 --> 00:00:37,260
I also have a value of B.
나는 또한 B의 값을 가지고 있습니다.

11
00:00:37,270 --> 00:00:43,720
That means my right lane condition and I can simply find the lane center from E and B.
그것은 나의 오른쪽 차선 상태를 의미하며 E와 B에서 차선 중심을 간단히 찾을 수 있습니다.

12
00:00:43,720 --> 00:00:49,690
So with the mathematics the lane center will be B minus eight divided by two plus E.
따라서 수학적으로 차선 중심은 B 빼기 8 나누기 2 더하기 E가 됩니다.

13
00:00:49,690 --> 00:00:54,880
So let us implement scheme in the C++ here for this task.
따라서 여기에서 이 작업을 위해 C++에서 체계를 구현해 보겠습니다.

14
00:00:54,880 --> 00:00:58,790
I will create a new function so let us create a new function.
새 함수를 만들 것이므로 새 함수를 만들어 보겠습니다.

15
00:00:58,840 --> 00:01:01,630
The function name there say Lane Center
기능 이름은 Lane Center라고 합니다.

16
00:01:04,970 --> 00:01:06,080
for a Bill Lane Center.
빌 레인 센터를 위해.

17
00:01:06,080 --> 00:01:10,760
I have to create a new integer variable so let's see Lane center
새로운 정수 변수를 생성해야 하므로 Lane 중심을 보겠습니다.

18
00:01:13,610 --> 00:01:19,530
and this land center will be a word rightly in position.
그리고 이 땅의 중심은 올바른 위치에 있는 단어가 될 것입니다.

19
00:01:19,550 --> 00:01:23,900
This is a will right lane position minus left lane position
이것은 의지 오른쪽 차선 위치에서 왼쪽 차선 위치를 뺀 값입니다.

20
00:01:26,420 --> 00:01:30,880
divided by two plus left lane position
2 더하기 왼쪽 차선 위치로 나눈 값

21
00:01:36,160 --> 00:01:38,530
and a left round bracket here.
여기에 왼쪽 둥근 브래킷이 있습니다.

22
00:01:38,590 --> 00:01:40,500
Next I have to create a new variable.
다음으로 새 변수를 만들어야 합니다.

23
00:01:40,510 --> 00:01:48,030
So this will also be integer variable and the name of the variable will be frame center.
따라서 이것은 또한 정수 변수가 될 것이며 변수의 이름은 프레임 중심이 될 것입니다.

24
00:01:48,040 --> 00:01:50,260
Now what will be our frame center.
이제 프레임 센터가 될 것입니다.

25
00:01:50,260 --> 00:01:55,900
It's simply 200 because I will frame is 400 and a frame center is 200
프레임이 400이고 프레임 중심이 200이기 때문에 단순히 200입니다.

26
00:01:58,890 --> 00:01:59,480
next.

27
00:01:59,560 --> 00:02:03,490
I have to declared all these variables globally.
이 모든 변수를 전역적으로 선언해야 합니다.

28
00:02:03,490 --> 00:02:07,670
Next day I will declare somewhere here.
다음날 나는 여기 어딘가에 선언 할 것입니다.

29
00:02:07,690 --> 00:02:10,310
First is our frame center.
먼저 프레임 센터입니다.

30
00:02:12,280 --> 00:02:17,420
And second one is of a lane center.
그리고 두 번째는 레인 센터입니다.

31
00:02:17,950 --> 00:02:21,000
I will draw a line from this lane center on the image.
이미지의 이 차선 중심에서 선을 그립니다.

32
00:02:21,340 --> 00:02:22,870
So our values align feature
따라서 우리의 가치는 기능을 정렬합니다.

33
00:02:29,490 --> 00:02:30,020
all right.

34
00:02:30,030 --> 00:02:33,780
So let's call this function in the y loop.
y 루프에서 이 함수를 호출해 보겠습니다.

35
00:02:33,780 --> 00:02:36,190
I will call it here.
나는 그것을 여기에서 부를 것이다.

36
00:02:36,360 --> 00:02:38,190
This is my lane center.
제 레인 센터입니다.

37
00:02:42,120 --> 00:02:50,530
Let's build the program now run the program.
이제 프로그램을 빌드해 보겠습니다.

38
00:02:50,550 --> 00:02:50,940
All right.

39
00:02:50,950 --> 00:02:53,620
So this is our lead center.
이것이 우리의 리드 센터입니다.

40
00:02:53,690 --> 00:02:54,400
I'm the same way.
나도 마찬가지야.

41
00:02:54,400 --> 00:03:00,190
I will also display a frame center here.
여기에 프레임 센터도 표시합니다.

42
00:03:00,190 --> 00:03:04,870
Now go to the same function just copy this
이제 동일한 기능으로 이동하여 이것을 복사하십시오.

43
00:03:12,360 --> 00:03:13,100
this time.
이 시간.

44
00:03:13,110 --> 00:03:20,350
This will be over a Freedom Center.
이것은 자유 센터를 넘을 것입니다.

45
00:03:20,730 --> 00:03:23,390
This will be also framed center.
이것은 또한 프레임 중심이 될 것입니다.

46
00:03:25,410 --> 00:03:28,170
And for the color I just want to use the blue color.
그리고 색상에는 파란색을 사용하고 싶습니다.

47
00:03:28,170 --> 00:03:34,590
So BGR I will change the 0 to 255 and green channel.
그래서 BGR I는 0을 255로 변경하고 녹색 채널을 변경합니다.

48
00:03:34,590 --> 00:03:38,230
I will make the intensity to zero.
강도를 0으로 만들겠습니다.

49
00:03:38,310 --> 00:03:40,820
Let's build a program.
프로그램을 만들어 봅시다.

50
00:03:41,370 --> 00:03:45,190
Let's run the program.

51
00:03:45,250 --> 00:03:45,660
All right.

52
00:03:45,660 --> 00:03:51,260
So this green line is of a line center and blue line is our frame center.
따라서 이 녹색 선은 선 중심이고 파란색 선은 프레임 중심입니다.

53
00:03:52,000 --> 00:03:54,340
So next step is our calibration.
따라서 다음 단계는 보정입니다.

54
00:03:54,340 --> 00:04:00,580
So in our calibration process what we will do we will try to overlap with this learning center two of
따라서 교정 프로세스에서 수행할 작업은 다음 중 두 가지 학습 센터와 중복되도록 시도할 것입니다.

55
00:04:00,590 --> 00:04:02,160
our frame center.
우리의 프레임 센터.

56
00:04:02,170 --> 00:04:09,310
So first of all let's try to place of a rowboat exactly at the center of the lane like I'm placing my
따라서 우선 내가 보트를 배치하는 것처럼 정확하게 차선 중앙에 노 젓는 보트를 배치해 보겠습니다.

57
00:04:09,310 --> 00:04:11,770
rowboat exactly at the center.
정확히 중앙에 노 젓는 배.

58
00:04:11,770 --> 00:04:18,720
Make sure the space from the both side of your room board should be seen in order to do proper calibration.
적절한 보정을 수행하기 위해 룸 보드의 양쪽에서 공간이 보여야 합니다.

59
00:04:18,730 --> 00:04:20,930
Now let's run the program again.
이제 프로그램을 다시 실행해 보겠습니다.

60
00:04:23,320 --> 00:04:26,440
So this time our robot is actually at the center.
그래서 이번에는 로봇이 실제로 중앙에 있습니다.

61
00:04:26,770 --> 00:04:33,340
So for this case we cannot change a word leaning Center because Leon Center is derived from over lines
따라서 이 경우 Leon Center가 over line에서 파생되기 때문에 단어 leaning Center를 변경할 수 없습니다.

62
00:04:33,670 --> 00:04:37,900
but we can change the frame center in order to merge with this Leon Center.
그러나 이 Leon Center와 병합하기 위해 프레임 중심을 변경할 수 있습니다.

63
00:04:38,290 --> 00:04:44,980
So whatever we do I try to shift this frame center to the left hand side so that it can easily overlap
그래서 우리가 무엇을 하든 이 프레임 중심을 왼쪽으로 이동하여 쉽게 겹칠 수 있도록 합니다.

64
00:04:45,040 --> 00:04:49,950
with our lead center.
우리의 리드 센터와 함께.

65
00:04:49,960 --> 00:04:52,730
Now look for a wall frame center.
이제 벽 프레임 센터를 찾으십시오.

66
00:04:52,750 --> 00:04:55,140
So we defined a frame center to 200.
그래서 우리는 프레임 중심을 200으로 정의했습니다.

67
00:04:55,630 --> 00:04:58,550
So let us shifted to the left side.
그럼 왼쪽으로 이동해 보겠습니다.

68
00:04:58,600 --> 00:05:03,940
Now I will define it as one 90 build program on game.
이제 게임에서 하나의 90 빌드 프로그램으로 정의하겠습니다.

69
00:05:04,810 --> 00:05:08,710
Let's run this now.

70
00:05:08,710 --> 00:05:14,260
Very small difference left just close the program shifted again.
아주 작은 차이는 프로그램을 닫으면 다시 쉬프트됩니다.

71
00:05:14,260 --> 00:05:16,120
Let's say this time one idiot
이번에는 바보라고 하자

72
00:05:20,830 --> 00:05:23,320
built up program and run it.
프로그램을 만들고 실행합니다.

73
00:05:23,490 --> 00:05:28,200
All right so over Leon Center is properly or leapt by a well frame center.
좋아, 레온 센터는 적절하게 또는 웰 프레임 센터에 의해 뛰어 넘습니다.

74
00:05:28,440 --> 00:05:30,110
So over calibration is done.
그래서 오버 캘리브레이션이 완료되었습니다.

75
00:05:30,120 --> 00:05:31,290
We can close this
우리는 이것을 닫을 수 있습니다

76
00:05:34,020 --> 00:05:34,830
at this point.

77
00:05:34,840 --> 00:05:38,460
We're done with our image processing for of a self-driving car.
우리는 자율주행차에 대한 이미지 처리를 마쳤습니다.

78
00:05:38,850 --> 00:05:43,890
So in the next step I will discuss how we can bring some useful data on our video frame.
따라서 다음 단계에서는 비디오 프레임에 유용한 데이터를 가져올 수 있는 방법에 대해 설명하겠습니다.
